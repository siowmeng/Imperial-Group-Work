---
title: "Analysis of IMDB Movie Dataset"
output: html_document
date: "16 October 2016"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(ggthemes)
library(ggrepel)
library(reshape2)
library(dplyr)
library(plyr)
library(caret)
library(scales)
library(countrycode)
library(GGally)
```


#Executive Summary
*to be filled out after we have finished our analysis*

#Introduction

*Introduction to go here (person to fill out TBD)*
*key purpose/concepts that we are trying to explore are what makes a movie popular (based on the gross revenue), and what makes a movie highly rated by the public (based on the imdb score)*

#Data

```{r, echo = FALSE}
movies <- read.csv(file = "movie_metadata.csv", header = TRUE, stringsAsFactors = FALSE, strip.white = TRUE)
```

*Explanation of the data and how it was extracted from IMDB to go here - Steven L*

* explain what IMDB is

The dataset used for this analysis was downloaded from Kaggle. The data was scraped from IMDB website using "Scrapy", a Python library. It contains `r dim(movies)[1]` movies with `r dim(movies)[2]` variables spanning 100 years and 66 countries. The dataset can be retrieved [here](https://www.kaggle.com/deepmatrix/imdb-5000-movie-dataset).

The dataset includes the following columns:
`r names(movies)`

*also to potentially include as discussed: explanation of each of the columns and what they mean (box office gross or total gross including dvd sales etc.? and budget as final budget or expected budget?*

# Data Cleansing

*As we agreed in the discussion - feel free to let me know if I made any mistakes - Louise to take the code from George/Stephen and add in the steps agreed below*

First we look into the amount of NA variables found in each column our data:

```{r, echo = FALSE}
## function to calculate list of NAs within a column
colNA <- function(dfCol){ sum(is.na(dfCol)) }
## To show table of sum of NAs by column
apply(movies, 2, colNA)
```

The following cleansing process is then applied:

* All rows where the title year is NA are removed - as there are a high number, and this variable is not expected to be key to the analysis.
* All rows where gross is NA are removed - as there are a high number, and this variable is expected to be one of the output variables
* All rows where the budget is NA are removed - as there are a high number, and this variable is expected to be key to the analysis.
* The aspect ratio column is removed - as there are a high number of NAs, and this variable is not expected to be key to the analysis. (*Louise comment - should we justify this somewhere?*)
* The IMDB link column is removed - as this variable is not expected to be key to the analysis

After this point there are only a few NAs remaining.

```{r, echo = FALSE}
## To remove rows where NAs are present for any of the applicable columns
movies <- movies[complete.cases(movies[c("title_year","budget","gross")]),]
## To remove aspect ratio and imdb link columns
movies$aspect_ratio<- NULL
movies$movie_imdb_link<- NULL
## To show table of sum of NAs by column
apply(movies, 2, colNA)
```

* For all other columns where there are NAs, the mean value will be used to replace all NAs within that column. Although this has some drawbacks in terms of accuracy, it allows us to maintain rows of data with other valid information, and is an unbiased approach to handling NAs.
*Louise comment - I will find some literature on this and explain it better*
```{r, echo = FALSE}
## for loop to replace NAs with means for particular columns
for (i in c("actor_1_facebook_likes" , "actor_2_facebook_likes" , "actor_3_facebook_likes" , "num_critic_for_reviews" , "duration" , "facenumber_in_poster"))
 {k <- which(colnames(movies)==i)
 movies[k][is.na(movies[k]==TRUE)] <- round(mean(movies[[k]], na.rm=TRUE),0)}
```

* Unwanted strings "Â" as well as leading and trailing white spaces are removed from the "title" column.

```{r, echo = FALSE}
movies <- movies[!duplicated(movies$movie_title),]
# Function to remove Â, leading and trailing whitespace from movies$movie_title
movie_title_processing <- function(str){
  str <- sub(pattern = "Â", replacement = "", str)
  str <- sub(pattern = "^\\s+|\\s+$", replacement ="", str)
}
# Apply previous function
movies$movie_title <- sapply(movies$movie_title, FUN = movie_title_processing)
```

Although some of these steps reduce the sample size for analysis, the rows removed would either cause later analysis to fail, cause the dataset to be inconsistent across various pieces of analysis, or produce misleading results.

This cleansed dataset (of `r nrow(movies)` rows) contains no NA values and is used for the remainder of the analysis.

```{r, echo = FALSE}
apply(movies, 2, colNA)
```
*General note: I plan to tidy up the writing here later but just wanted to get down our discussion :)*

```{r, echo = FALSE, message = FALSE}
set.seed(1)
intrain <- createDataPartition(y = movies[[1]], p = 0.9, list = FALSE)
train <- movies[intrain, ]
test <- movies[-intrain, ]
```

10% of the cleansed dataset (`r nrow(test)`) is then set aside to be the "test" dataset, leaving the remaining 90%  of our dataset (`r nrow(movies)`) as the training dataset. The training dataset alone will be used for all descriptive, inferential and predictive analysis, including model building. The "test" dataset will be used at a later stage to check the accuracy of the predicted model.


# Descriptive Data Analysis

*For now, each have a section with one (or more) descriptive plot, later we can discuss how this flows into a narrative - we should let everyone in the slack group know what we're doing so that we don't overlap unecessarily**

*different options we discussed are:*

* *Map diagram with bubbles showing movies by country*
* *Time analysis - multiple boxplots for each decade (LF note: could also be under inference - if you then want to discuss whether decade is a good predictor of revenue - might get different results if you take decade as a number or a factor)*
* *imdb score against gross coloured by: actor/director/country*
* *frequency of movies with different genres/keywords - (George has already done this)*
* *Ratings broken down by genre (boxplot)*
* *Top actors in terms of facebook likes*
* *Analysis of top movies (by score and gross)*
* *Total number of facebook likes - histogram*

### Siow Meng

```{r, echo = FALSE}

revYear <- ddply(movies, ~ title_year, summarise, meanRev = mean(gross, na.rm = TRUE))

ggplot(data = revYear, aes(x = title_year, y = meanRev)) + geom_line() + labs(title = "Average Gross Revenue from Year 1920 to 2016", x = "Year", y = "Average Revenue") + coord_cartesian(xlim = c(1920, 2016))

revLanguage <- ddply(movies, ~ title_year + language, summarise, meanRev = mean(gross, na.rm = TRUE))

ggplot(data = revLanguage[revLanguage$language == "English", ], aes(x = title_year, y = meanRev)) + geom_line() + labs(title = "Average Gross Revenue of English Movies from Year 1920 to 2016", x = "Year", y = "Average Revenue") + coord_cartesian(xlim = c(1920, 2016))

ggplot(data = revLanguage[revLanguage$language != "English", ], aes(x = title_year, y = meanRev)) + geom_line() + labs(title = "Average Gross Revenue of Non-English Movies from Year 1920 to 2016", x = "Year", y = "Average Revenue") + coord_cartesian(xlim = c(1920, 2016))

# Correlation plot from Louise

moviesnumeric<- movies[c("duration", "title_year", "budget", "imdb_score", "movie_facebook_likes", "actor_1_facebook_likes", "actor_2_facebook_likes", "actor_3_facebook_likes", "cast_total_facebook_likes", "director_facebook_likes", "num_user_for_reviews", "num_critic_for_reviews", "facenumber_in_poster", "gross")]

##used pairwise complete obs to handle NAs for fields with a high number of nas
corrmatrix <- round(cor(moviesnumeric, use="pairwise.complete.obs"), 2)
meltedmovies<- melt(corrmatrix)
ggplot(data = meltedmovies, aes(x=Var1, y=Var2, fill=value)) + geom_tile() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(x="", y="") + ggtitle("Correlation Matrix")

# Added correlation plot for movies after 2005
corrmatrix2005 <- round(cor(moviesnumeric[moviesnumeric$title_year >= 2005, ], use="pairwise.complete.obs"), 2)
meltedmovies2005 <- melt(corrmatrix2005)
ggplot(data = meltedmovies2005, aes(x=Var1, y=Var2, fill=value)) + geom_tile() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(x="", y="") + ggtitle("Correlation Matrix")

# Added correlation plot for movies after 2010
corrmatrix2010 <- round(cor(moviesnumeric[moviesnumeric$title_year >= 2010, ], use="pairwise.complete.obs"), 2)
meltedmovies2010 <- melt(corrmatrix2010)
ggplot(data = meltedmovies2010, aes(x=Var1, y=Var2, fill=value)) + geom_tile() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(x="", y="") + ggtitle("Correlation Matrix")

```

### Nikhita

```{r}
# Sorting the movies by country and picking out the top 10
counted <- count(movies, 'country')
removednas <- counted[complete.cases(counted),]
sorted <- arrange(removednas, desc(freq))
topcountries <- sorted[1:10,]
topcountries$country <- factor(topcountries$country, levels = topcountries$country[order(topcountries$freq)])

# Taking the countries with more than 10 movies
countries <- subset(movies, country %in% c("Australia", "Canada", "China", "France", "Germany", "India", "Japan", "Spain", "UK", "USA"))

score <- countries$imdb_score
gross <- countries$gross

# Plot of gross revenue for the above countries
ggplot(countries, aes(country, gross, fill = country)) + 
    geom_boxplot() + 
    labs(title = "Gross revenue of movies by country", x = "", y = "Gross revenue") + 
    theme_few() +
    theme(legend.position = "None") +
    theme(axis.ticks.y = element_blank()) + 
    scale_y_log10(breaks = c(1e+02, 1e+04, 1e+06, 1e+08, 1e+10), 
                  labels = c("100", "10,000", "1 million", "100 millions", "1 billion"))

# Plot of imdb score for the above movies
ggplot(countries, aes(country, score, fill = country)) + 
    geom_boxplot() + 
    labs(title = "IMDB SCore of movies by country", x = "", y = "Gross revenue") + 
    theme_few() +
    theme(legend.position = "None") +
    theme(axis.ticks.y = element_blank()) + 
    scale_y_log10(breaks = c(1e+02, 1e+04, 1e+06, 1e+08, 1e+10), 
                  labels = c("100", "10,000", "1 million", "100 millions", "1 billion"))

ggplot(countries, aes(x = score, y = gross, colour = country)) + 
  geom_jitter() + scale_x_log10()+ labs(title = "Budget and Gross Revenue for different countries", x = "IMDB Score", y = "Gross Revenue") +
  facet_wrap(~ country) +
  theme_few() + 
  theme(legend.position = "None")
```


### Cecilia

Will do a plot for budget vs gross and budget vs imdb score *test*

```{r}

##Histogram for movie budget
ggplot(data=movies, aes(movies$budget)) + geom_histogram(fill="#FF9999", colour="black") + scale_x_log10() + labs(x = "Budget", y="Count") 


##Country vs budget boxplot

#Find out which countries with over 10 movies in data set
subsetcountry <- count(movies, vars = "country") 
subsetcountry <- subsetcountry[order(subsetcountry[,2], decreasing = TRUE),] 
subsetcountry <- subsetcountry[subsetcountry[,2] >= 10,]
ggplot(data = subsetcountry) + geom_bar(aes(x = country, y = freq), stat="identity")

#Create dataframe with just Australia, Canada, China, France, Germany, Hong Kong, India, Italy, Japan, Mexico, Spain, UK, USA

budgetcountry <- subset(movies, country %in% c("Australia", "Canada", "China", "France", "Germany", "Hong Kong", "India", "Italy", "Japan", "Mexico", "Spain", "UK", "USA"))

#box plot for countries vs budget

ggplot(data = budgetcountry) + geom_boxplot(aes(x = country, y = budget, fill = country)) + scale_y_log10() + labs(x = "Country", y="Budget (USD)") + ggtitle("Budget of films by country") + theme(legend.position="none")




```


### George

Will do an analysis on *Gross revenue* and *IMDB score* based on *Genres* and *Plot Keywords*. :)

##### Genres

Descriptive analysis based on the movies genres and how do they correlate possibly with other variables of the dataset. Genres with less than 10 movies have been omitted. The first graph shows the number of movies in each genre while the second and the third plots present a boxplot for each genre associated with the profit of the movies and the IMDB score of the movies respectively.

```{r, echo = FALSE, fig.width = 10, fig.align = "center"}
genres <- c()
i <- 1
for (ins in movies$genres){
    g <- strsplit(ins, "[|]")
    for (gnr in g[[1]]){
        if (!(gnr %in% genres)){
            genres[i] <- gnr
            i = i + 1
        }
    }
}
# Create a dataframe with logical values which 
# indiacte the categories of each movie
movies$genres <- strsplit(movies$genres, "[|]")
genres_idx <- movies[, c("movie_title", "genres")]
i = 1
mat <- matrix(rep(0, (dim(movies)[1] * length(genres))), nrow = dim(movies)[1])
for (g in genres_idx$genres){
    idx <- which(genres %in% g)
    mat[i, idx] <- 1
    i = i + 1
}
colnames(mat) <- genres
movies_and_genres <- data.frame(mat)

# Find how many movies belong in each genre
sum <- rep(0, length(genres))
for (i in 1:length(genres)){
    sum[i] <- sum(movies_and_genres[, i])
}
genres_sum <- data.frame(genre = factor(genres), sum = sum)
genres_sum <- genres_sum[order(sum, decreasing = FALSE),]
genres_sum$genre <- factor(genres_sum$genre, levels = genres_sum$genre)
genres_sum <- genres_sum[genres_sum$sum > 10, ]

# Number of movies belonging to each genre
ggplot(genres_sum, aes(x = genre, y = sum, fill = genre)) + 
    geom_bar(stat = "identity", colour = "black") + 
    coord_flip() +
    labs(title = "Number of movies by genre", x = "", y = "") + 
    geom_text(aes(label = sum), hjust = -0.2, vjust = 0.4) + 
    theme_few() +
    theme(legend.position = "None") +
    theme(axis.text.x=element_blank(), axis.ticks.x = element_blank(), axis.ticks.y = element_blank()) 

######################### Create an appropriate dataframe with gross, imdb_score and genres for each movie
movies_and_genres <- cbind(gross = movies$gross, score = movies$imdb_score, movie_title = movies$movie_title, movies_and_genres, stringsAsFactors = FALSE)
movies_and_genres <- melt(movies_and_genres, id = c("gross", "score", "movie_title"))
movies_and_genres$variable <- gsub("[.]", " ", movies_and_genres$variable)
movies_and_genres <- movies_and_genres[movies_and_genres$value == 1, ] 
movies_and_genres$value <- NULL
colnames(movies_and_genres) <- c("gross", "score", "movie_title", "genre")
movies_and_genres$genre <- factor(movies_and_genres$genre, levels = genres_sum$genre)
movies_and_genres <- movies_and_genres[complete.cases(movies_and_genres), ]

# Boxplot of genres and profit
ggplot(movies_and_genres, aes(genre, gross, fill = genre)) + 
    geom_boxplot() + 
    coord_flip() +
    labs(title = "Gross revenue of movies by genre", x = "", y = "Gross revenue") + 
    theme_few() +
    theme(legend.position = "None") +
    theme(axis.ticks.y = element_blank()) + 
    scale_y_log10(breaks = c(1e+02, 1e+04, 1e+06, 1e+08, 1e+10), 
                  labels = c("100", "10,000", "1 million", "100 millions", "1 billion"))

# Boxplot of genres and imdb score
ggplot(movies_and_genres, aes(genre, score, fill = genre)) + 
    geom_boxplot() + 
    coord_flip() +
    labs(title = "IMDB score of movies by genre", x = "", y = "IMDB score") + 
    theme_few() +
    theme(legend.position = "None") +
    theme(axis.ticks.y = element_blank()) +
    scale_y_continuous(breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9))

# Scatter plots of genres based on gross and imdb score
ggplot(movies_and_genres, aes(x = gross, y = score, colour = genre)) + 
  geom_jitter(alpha = 0.1) +
  scale_x_log10(breaks = c(1e+02, 1e+04, 1e+06, 1e+08, 1e+10), 
                labels = c("100", "10,000", "1 million", "100 millions", "1 billion")) +
  labs(title = "Gross Revenue and IMDB score for different genres", x = "Gross Revenue", y = "IMDB Score") +
  facet_wrap(~ genre) +
  theme_few() + 
  theme(legend.position = "None")
```


#### Plot Keywords

We display the 20 most popular keywords.

```{r, echo = FALSE, fig.width = 10, fig.align = "center"}
movies0 <- movies[movies$plot_keywords != "", ]
keywords <- c()
i <- 1
for (ins in movies0$plot_keywords){
    kw <- strsplit(ins, "[|]")
    if (length(kw) != 0){
        for (word in kw[[1]]){
            if (!(word %in% keywords)){
                keywords[i] <- word
                i = i + 1
            }
        }
    }
}
# Create a dataframe with logical values which 
# indiacte the keywords of each movie
movies0$plot_keywords <- strsplit(movies0$plot_keywords, "[|]")
keywords_idx <- movies0[, c("movie_title", "plot_keywords")]
i = 1
mat <- matrix(rep(0, (dim(movies0)[1] * length(keywords))), nrow = dim(movies0)[1])
for (word in keywords_idx$plot_keywords){
    idx <- which(keywords %in% word)
    mat[i, idx] <- 1
    i = i + 1
}
colnames(mat) <- keywords
movies_and_keywords <- data.frame(mat)

# Find how many movies belong in each keyword
sum <- rep(0, length(keywords))
for (i in 1:length(keywords)){
    sum[i] <- sum(movies_and_keywords[, i])
}
keywords_sum <- data.frame(keywords = factor(keywords), sum = sum)
keywords_sum <- keywords_sum[order(sum, decreasing = FALSE),]
keywords_sum$keywords <- factor(keywords_sum$keywords, levels = keywords_sum$keywords)
#keywords_sum <- keywords_sum[keywords_sum$sum > 39, ]
keywords_sum <- keywords_sum[(dim(keywords_sum)[1]-19):dim(keywords_sum)[1] ,]

# Number of most popular keywords
ggplot(keywords_sum, aes(x = keywords, y = sum, fill = keywords)) + 
    geom_bar(stat = "identity", colour = "black") + 
    coord_flip() +
    labs(title = "Number of movies by keyword", x = "", y = "") + 
    geom_text(aes(label = sum), hjust = -0.2, vjust = 0.4) + 
    theme_few() +
    theme(legend.position = "None") +
    theme(axis.text.x=element_blank(), axis.ticks.x = element_blank(), axis.ticks.y = element_blank()) 

######################### Create an appropriate dataframe with gross, imdb_score and keywords    for each movie
movies_and_keywords <- cbind(gross = movies0$gross, score = movies0$imdb_score, movies_and_keywords, stringsAsFactors = FALSE)
movies_and_keywords <- melt(movies_and_keywords, id = c("gross", "score"))
movies_and_keywords$variable <- gsub("[.]", " ", movies_and_keywords$variable)
movies_and_keywords <- movies_and_keywords[movies_and_keywords$value == 1, ] 
movies_and_keywords$value <- NULL
colnames(movies_and_keywords) <- c("gross", "score", "keywords")
movies_and_keywords$keywords <- factor(movies_and_keywords$keywords, levels = keywords_sum$keywords)
movies_and_keywords <- movies_and_keywords[complete.cases(movies_and_keywords), ]

# Boxplot of genres and profit
ggplot(movies_and_keywords, aes(keywords, gross, fill = keywords)) + 
    geom_boxplot() + 
    coord_flip() +
    labs(title = "Gross revenue of movies by keyword", x = "", y = "Gross revenue") + 
    theme_few() +
    theme(legend.position = "None") +
    theme(axis.ticks.y = element_blank()) + 
    scale_y_log10(breaks = c(1e+02, 1e+04, 1e+06, 1e+08, 1e+10), 
                  labels = c("100", "10,000", "1 million", "100 millions", "1 billion"))

# Boxplot of genres and imdb score
ggplot(movies_and_keywords, aes(keywords, score, fill = keywords)) + 
    geom_boxplot() + 
    coord_flip() +
    labs(title = "IMDB score of movies by keyword", x = "", y = "IMDB score") + 
    theme_few() +
    theme(legend.position = "None") +
    theme(axis.ticks.y = element_blank()) +
    scale_y_continuous(breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9))

# Scatter plots of keywords based on gross and imdb score
ggplot(movies_and_keywords, aes(x = gross, y = score, colour = keywords)) + 
  geom_jitter(alpha = 0.2) +
  scale_x_log10(breaks = c(1e+02, 1e+04, 1e+06, 1e+08, 1e+10), 
                labels = c("100", "10,000", "1 million", "100 millions", "1 billion")) +
  labs(title = "Gross Revenue and IMDB score for different keywords", x = "Gross Revenue", y = "IMDB Score") +
  facet_wrap(~ keywords, nrow = 4) +
  theme_few() + 
  theme(legend.position = "None")
```

### Steven
Boxplot IMDB scores against year, decade
```{r, echo = FALSE}

# create continent column
movies$continent <- countrycode(as.character(movies$country), "country.name", "continent")

# divide "Americas" into "North Americas" and "South America"
south_America = c("Brazil", "Argentina", "Chile", "Colombia", "Peru")

for (i in 1:nrow(movies)) {
  if (is.na(movies$continent[i])) {
    next
  } else if ((movies$continent[i] == "Americas") & (movies$country[i] %in% south_America)) {
    movies$continent[i] <- "South America"
  } else if ((movies$continent[i] == "Americas") & (!(movies$country[i] %in% south_America))) {
    movies$continent[i] <- "North America"
  } 
}

# for all countries and all years
# remove NA from title_year column first 
temp <- movies[!is.na(movies$title_year),]
ggplot(temp, aes(x = factor(title_year), y = imdb_score, fill = factor(title_year))) + 
  geom_boxplot() +
  theme(axis.text.x=element_text(angle=45, hjust=0.5, vjust=0.5), legend.position = "None") +
  labs(title = "IMDB scores against year", x = "", y = "IMDB Score")

# make decade column
convert_decade <- function(year){
  low <- year - year %% 10
  high <- year - year %% 10 + 9
  paste(as.character(low), as.character(high), sep = "-")
}

# apply function to create decade column
movies$decade <- sapply(movies$title_year, convert_decade)

# for all countries by decade
# remove entries with NA-NA
temp <- movies[!movies$decade == "NA-NA", ]
ggplot(temp, aes(x = decade, y = imdb_score, fill = decade)) + 
  geom_boxplot() +
  theme(axis.text.x=element_text(angle=45, hjust=0.5, vjust=0.5), legend.position = "None") +
  labs(title = "IMDB scores against decade, all countries", x = "", y = "IMDB Score")

# for Europe
temp <- movies[!movies$decade == "NA-NA", ]
temp <- temp[temp$continent == "Europe", ]
ggplot(temp, aes(x = decade, y = imdb_score, fill = decade)) + 
  geom_boxplot() +
  theme(axis.text.x=element_text(angle=45, hjust=0.5, vjust=0.5), legend.position = "None") +
  labs(title = "IMDB scores against decade, Europe", x = "", y = "IMDB Score")

# for North America
temp <- movies[!movies$decade == "NA-NA", ]
temp <- temp[temp$continent == "North America", ]
ggplot(temp, aes(x = decade, y = imdb_score, fill = decade)) + 
  geom_boxplot() +
  theme(axis.text.x=element_text(angle=45, hjust=0.5, vjust=0.5), legend.position = "None") +
  labs(title = "IMDB scores against decade, North America", x = "", y = "IMDB Score")

# for France
temp <- movies[!movies$decade == "NA-NA", ]
temp <- temp[temp$country == "France", ]
ggplot(temp, aes(x = decade, y = imdb_score, fill = decade)) + 
  geom_boxplot() +
  theme(axis.text.x=element_text(angle=45, hjust=0.5, vjust=0.5),legend.position = "None") +
  labs(title = "IMDB scores against decade, France", x = "", y = "IMDB Score")

# for Germany
temp <- movies[!movies$decade == "NA-NA", ]
temp <- temp[temp$country == "Germany", ]
ggplot(temp, aes(x = decade, y = imdb_score, fill = decade)) + 
  geom_boxplot() +
  theme(axis.text.x=element_text(angle=45, hjust=0.5, vjust=0.5), legend.position = "None") +
  labs(title = "IMDB scores against decade, Germany", x = "", y = "IMDB Score")

# for USA
temp <- movies[!movies$decade == "NA-NA", ]
temp <- temp[temp$country == "USA", ]
ggplot(temp, aes(x = decade, y = imdb_score, fill = decade)) + 
  geom_boxplot() +
  theme(axis.text.x=element_text(angle=45, hjust=0.5, vjust=0.5), legend.position = "None") +
  labs(title = "IMDB scores against decade, USA", x = "", y = "IMDB Score")

# for UK
temp <- movies[!movies$decade == "NA-NA", ]
temp <- temp[temp$country == "UK", ]
ggplot(temp, aes(x = decade, y = imdb_score, fill = decade)) + 
  geom_boxplot() +
  theme(axis.text.x=element_text(angle=45, hjust=0.5, vjust=0.5), legend.position = "None") +
  labs(title = "IMDB scores against decade, UK", x = "", y = "IMDB Score")

# for India
temp <- movies[!movies$decade == "NA-NA", ]
temp <- temp[temp$country == "India", ]
ggplot(temp, aes(x = decade, y = imdb_score, fill = decade)) + 
  geom_boxplot() +
  theme(axis.text.x=element_text(angle=45, hjust=0.5, vjust=0.5), legend.position = "None") +
  labs(title = "IMDB scores against decade, India", x = "", y = "IMDB Score")

# for China
temp <- movies[!movies$decade == "NA-NA", ]
temp <- temp[temp$country == "China", ]
ggplot(temp, aes(x = decade, y = imdb_score, fill = decade)) + 
  geom_boxplot() +
  theme(axis.text.x=element_text(angle=45, hjust=0.5, vjust=0.5), legend.position = "None") +
  labs(title = "IMDB scores against decade, China", x = "", y = "IMDB Score")
```

###Louise

```{r echo = FALSE, message = FALSE}
##create summary statistics for average imdb score & number of movies for each director
directorssummary <- ddply(movies, ~ director_name,summarise,score_average=round(mean(imdb_score),2), gross_average=round(mean(gross),2), number_of_movies=length(director_name))
##sort by # of movies then imdb average score
sorteddirectorsummary <- arrange(directorssummary,desc(number_of_movies), desc(score_average))
##ensure that factors are in the order of number of movies, otherwise ggplot will default to alphabetical ordering in the graph
sorteddirectorsummary$director_name <- factor(sorteddirectorsummary$director_name, levels = sorteddirectorsummary$director_name[order(sorteddirectorsummary$number_of_movies)])
```

There are `r nrow(sorteddirectorsummary)` distinct directors in the data sample.The density of movies per director is as below:

```{r echo=FALSE}
##Histogram for number of moveies per director
ggplot(sorteddirectorsummary, aes(x=number_of_movies)) + geom_histogram(binwidth=1, fill="darkblue") + labs(x = "Number of movies in sample") + ggtitle("Density of number of movies per director")
```

```{r echo=FALSE}
##add a categorical variable for one movie or more
sorteddirectorsummary$more_than_one_movie <- rep.int(0, nrow(sorteddirectorsummary))
sorteddirectorsummary$more_than_one_movie[sorteddirectorsummary$number_of_movies>1] <- 1
##calculate the percentage of directors with exactly one movie
dirpercentage <- round(100*length(sorteddirectorsummary$number_of_movies[sorteddirectorsummary$number_of_movies==1])/length(sorteddirectorsummary$number_of_movies),2)
```

This is clearly positively skewed, with many directors having only 1 movie in the dataset, and only a few having significantly more. In fact, approximately  `r dirpercentage` of those directors have only 1 movie in the top 5000, leaving `r 100-dirpercentage` that have more than 1.

An initial look at the relationship between # of movies that the director has in the dataset, and gross revenue does not show a clearly defined correlation:

```{r echo=FALSE}
##add # of movies per director to the main dataset.
movieswithdirectordata <- merge(movies, sorteddirectorsummary, by="director_name")
movieswithdirectordata <- rename(movieswithdirectordata, c('number_of_movies'='dir_number_of_movies'))
```

```{r echo=FALSE}
##function to create human readable axis labels.
##code taken from publically available github to give human readable axis labels. (https://github.com/fdryan/R/blob/master/ggplot2_formatter.r)
human_numbers <- function(x = NULL, smbl =""){
  humanity <- function(y){             
    
    if (!is.na(y)){
      
       b <- round_any(abs(y) / 1e9, 0.1)
       m <- round_any(abs(y) / 1e6, 0.1)
       k <- round_any(abs(y) / 1e3, 0.1)
      
      if ( y >= 0 ){ 
        y_is_positive <- ""
      } else {
        y_is_positive <- "-"
      }
      
      if ( k < 1 ) {
        paste0(y_is_positive, smbl, y )
        } else if ( m < 1){
        paste0 (y_is_positive, smbl,  k , "k")
      } else if (b < 1){
        paste0 (y_is_positive, smbl, m ,"m")
      } else {
        paste0 (y_is_positive, smbl,  comma(b), "b")     
      }
    }
  }
  
  sapply(x,humanity)
}

human_num   <- function(x){human_numbers(x, smbl = "")} 
human_usd   <- function(x){human_numbers(x, smbl = "$")}
```

```{r echo=FALSE, message=FALSE}
##plot for gross revenue vs score
## to do - sort out the axes
ggplot(movieswithdirectordata, aes(x = dir_number_of_movies, y = gross)) + 
  geom_jitter(alpha = 0.2, width = 0.05) +
  labs(x = "Number of movies by director in sample", y = "Average Gross Revenue") + scale_y_continuous(label=human_usd)
```

If we then split this out by decades, we can see the below:
```{r}
##add the decades in as per Steven's code (note: potentially change into a function?)
for (i in 1:nrow(movies)){
  low <- movieswithdirectordata$title_year[i] - (movieswithdirectordata$title_year[i] %% 10)
  high <- movieswithdirectordata$title_year[i] - (movieswithdirectordata$title_year[i] %% 10) + 9
  movieswithdirectordata$decade[i] <- paste(as.character(low), as.character(high), sep = "-")}
```

```{r echo=FALSE}
ggplot(movieswithdirectordata, aes(x = dir_number_of_movies, y = gross, colour = decade)) + 
  geom_jitter(alpha = 0.1) + scale_y_continuous(label=human_usd) + labs(title = "Gross Revenue and # of director movies for different decades", x = "# of Movies by Director", y = "Gross Revenue") + facet_wrap(~ decade, ncol = 5) + theme(legend.position = "None") + geom_smooth(color="#000000")
```

As the number of data elements in the sample grows for each decade, a geomtrical pattern also seems to emerge, which is an upwards trend of gross revenue by movies per director up to about 10 movies per director, andthen a less clear trend for movies for movies with 10+ movies per director.

Similarly for genres:

```{r echo=FALSE}
movies_and_genres_withdirectordata <- merge(movies_and_genres, movieswithdirectordata[,c("movie_title","dir_number_of_movies")], by="movie_title")
```

```{r echo=FALSE}
##requires the above
ggplot(movies_and_genres_withdirectordata, aes(x = dir_number_of_movies, y = gross, colour = genre)) + 
  geom_jitter(alpha = 0.1) + scale_y_continuous(label=human_usd) + labs(title = "Gross Revenue and # of director movies for different genres", x = "# of Movies by Director", y = "Gross Revenue") + facet_wrap(~ genre) + theme(legend.position = "None") + geom_smooth(color="#000000")
```

Most of the genres also seem to approximately follow the pattern of a positive correlation up to 10 movies by director, and then a less predictable path for those with directors with higher numbers of movies.

```{r echo=FALSE}
##add a categorical variable for one movie or more
sorteddirectorsummary$more_than_ten_movies <- rep.int(0, nrow(sorteddirectorsummary))
sorteddirectorsummary$more_than_ten_movies[sorteddirectorsummary$number_of_movies>=10] <- 1
##calculate the percentage of directors with exactly one movie
morethantendirpercentage <- round(100*length(sorteddirectorsummary$number_of_movies[sorteddirectorsummary$more_than_ten_movies==1])/length(sorteddirectorsummary$number_of_movies),2)

movieswithdirectordata <- merge(movieswithdirectordata, sorteddirectorsummary[,c("director_name","more_than_ten_movies")], by="director_name")

morethantenmovpercentage <- round(100*length(movieswithdirectordata$more_than_ten_movies[movieswithdirectordata$more_than_ten_movies==1])/length(movieswithdirectordata$more_than_ten_movies),2)

```

Only approximately `r morethantendirpercentage`% directors have more than ten movies, which, when considering movies, constitutes approximately `r morethantenmovpercentage`% of movies in our sample.

# Inferential Data Analysis

*For now, each have a section with one comparison and test/set of tests (t.test, var.test, cor.test etc.), it is expected this section will also include plots, later we can discuss how this flows into a narrative - we should let everyone in the slack group know what we're doing so that we don't overlap unecessarily*

*It is expected that these will be related to how inputs are correlated with the two outcome variables (gross and imdb_score)*

### Siow Meng

```{r echo=FALSE}
# boxplot of English & Non-English movies
temp <- movies

temp$english <- factor(temp$language == "English", levels = c(TRUE, FALSE), labels = c("English", "Non-English"))

ggplot(data = temp, aes(x = english, y = gross)) + geom_boxplot() + labs(title = "Gross Revenue of English and non-English Movies", x = "English or Non-English Movies", y = "Gross Revenue") + coord_cartesian(ylim = c(0, 1e8))

t.test(movies$gross[movies$language == "English"], movies$gross[movies$language != "English"], alternative = "greater")

var.test(movies$gross[movies$language == "English"], movies$gross[movies$language != "English"], alternative = "greater")

```

From the above box-and-whisker plots, we can observe a great difference between the revenues achieved by English and non-English movies. More than 75% of the non-English movies achieved gross revenue of US$10 million or lower. In contrast, more than half of the English movies have more than US$25 million revenues.

In addition, the gross revenues of English movies vary greatly (compared to non-English movies).

We are confident to say that the English movies in this dataset are generally more popular than non-English movies.

### Nikhita

Looking at the content rating for the movies

```{r}

ratingcounts <- count(movies, 'content_rating')
ratingsort <- arrange(ratingcounts, desc(freq))
topratings <- ratingsort[1:5,]

topratedmovies <- subset(movies, content_rating %in% c("PG-13", "R", "PG"))
contentrating <- topratedmovies$content_rating
contentscore <- topratedmovies$imdb_score
contentgross <- topratedmovies$gross

ggplot(topratedmovies, aes(contentrating, contentscore, fill = contentrating)) + 
    geom_boxplot() + 
    labs(title = "IMDB Score of movies by rating", x = "Content Rating", y = "IMDB Score") + 
    theme_few() +
    theme(legend.position = "None") +
    theme(axis.ticks.y = element_blank()) + 
    scale_y_log10(breaks = c(1e+02, 1e+04, 1e+06, 1e+08, 1e+10), 
                  labels = c("100", "10,000", "1 million", "100 millions", "1 billion"))

ggplot(topratedmovies, aes(contentrating, contentgross, fill = contentrating)) + 
    geom_boxplot() + 
    labs(title = "Gross Revenue of movies by rating", x = "Content Rating", y = "Gross Revenue") +
    theme_few() +
    theme(legend.position = "None") +
    theme(axis.ticks.y = element_blank()) + 
    scale_y_log10(breaks = c(1e+02, 1e+04, 1e+06, 1e+08, 1e+10), 
                  labels = c("100", "10,000", "1 million", "100 millions", "1 billion"))

# Does the overall IMDB Score vary with different ratings?
t.test(movies$imdb_score[movies$content_rating == "R"], movies$imdb_score[movies$content_rating == "PG-13"])

t.test(movies$imdb_score[movies$content_rating == "PG-13"], movies$imdb_score[movies$content_rating == "G"])

t.test(movies$imdb_score[movies$content_rating == "R"], movies$imdb_score[movies$content_rating == "G"])
```

### Cecilia

Budget vs IMDB score

```{r}

#scatter plot for budget vs imdb score

ggplot(data = movies) + geom_point(aes(x = budget, y = imdb_score, colour="#FF9999")) + labs(x = "Budget", y = "IMDB Score") + scale_x_log10(breaks = c(1e+03, 1e+05, 1e+07, 1e+09), labels = c("1000", "100,000", "10 million", "1000 million")) + theme(legend.position="none")


#covariance test

cov(movies$budget, movies$imdb_score)

#correlation test

cor.test(movies$budget, movies$imdb_score)

```

The covariance value of 5306036 suggests that there is an upward trend, as budget increases, imdb score increases. The Pearson's correlation test between budget and IMDB score gives us a p-value of 0.047, which suggests that there isn't a high correlation between budget of the movie and rating on IMDB. 

Even if we dig deeper to look at the effect of budget on IMDB score for movies from different countries, it appears to be that there is not much of a trend.


```{r}

ggplot(data = budgetcountry) + geom_jitter(aes(x = budget, y = imdb_score, color=country, alpha = 0.1)) + labs(x = "Budget", y = "IMDB Score") + scale_x_log10() 


ggplot(budgetcountry, aes(x = budget, y = imdb_score, colour = country)) + 
  geom_jitter() + scale_x_log10()+ labs(title = "Budget and IMDB score for different genres", x = "Budget", y = "IMDB Score") +
  facet_wrap(~ country) +
  theme_few() + 
  theme(legend.position = "None")

```


Budget vs Gross

```{r}

#scatter plot for budget vs gross

ggplot(data = movies) + geom_point(aes(x = budget, y = gross, colour="#FF9999")) + labs(x = "Budget", y = "Gross Revenue in USD") + scale_x_log10(breaks = c(1e+03, 1e+05, 1e+07, 1e+09), labels = c("1000", "100,000", "10 million", "1000 million")) + theme(legend.position="none")

#covariance test

cov(movies$budget, movies$gross)

#correlation test

cor.test(movies$budget, movies$gross)

```

The covariance value of 1.6 x 10^15 suggests that there is an upward trend, as budget increases, revenue from the movie increases. The Pearson's correlation test between budget and gross gives us a value of 0.22, which suggests that there isn't a high correlation between budget of the movie and gross, but slightly higher than the correlation between movie and imdb score.

If we subset the data by different countries, we still do not see a huge correlation between budget versus gross revenue.

```{r}

ggplot(data = budgetcountry) + geom_jitter(aes(x = budget, y = gross, color=country, alpha = 0.1)) + labs(x = "Budget", y = "Gross Revenue") + scale_x_log10() 


ggplot(budgetcountry, aes(x = budget, y = gross, colour = country)) + 
  geom_jitter() + scale_x_log10()+ labs(title = "Budget and Gross Revenue for different countries", x = "Budget", y = "Gross Revenue") +
  facet_wrap(~ country) +
  theme_few() + 
  theme(legend.position = "None")

```


As both variables are indicators of a movie's popularity, we can conclude from the above analysis that budget does not have a huge influence on how 'popular' a movie is.



Budget vs Gross Profit Margin

```{r}

#create grossprofit column
movieswprofit <- data.frame(movies)
movieswprofit$grossprofitmargin <- (movieswprofit$gross - movieswprofit$budget)/movieswprofit$gross * 100

#scatter plot for budget vs gross profit margin 
ggplot(data = movieswprofit) + geom_point(aes(x = budget, y = grossprofitmargin, colour = "#FF9999")) + scale_x_log10(breaks = c(1e+03, 1e+05, 1e+07, 1e+09), labels = c("1000", "100,000", "10 million", "1000 million")) + theme(legend.position="none") + scale_y_continuous(limits = c(-1000, 100)) + theme(legend.position="none") + labs(x = "Budget in USD", y = "Gross Profit Margin as %")


#covariance test

cov(movieswprofit$budget, movieswprofit$grossprofitmargin, use = "complete.obs") 

#correlation test

cor.test(movieswprofit$budget, movieswprofit$grossprofitmargin, use = "complete.obs")

```

Finally, we would also like to look at the effect of gross vs on gross profit margin, whether the an increase in budget would make a better movie, and hence a higher gross profit margin. Gross profit margin can be used as an indictor of profitability of movie. Based on the data, it appears that there is a negative correlation (-0.31) between budget and profit. Although it is not very strong, it still suggests that an increase in budget has a slight negative impact on gross profit margin.


### George

In case of nominal variables it doesn't make sense to talk about what happens if these variables increase/decrease, because they don't have a numerical value that can go up/down. So we can correlate neither "Genres" nor "Keywords" with "Gross Revenue" or "IMDB Score". However, there are measures of strength of association we can use that are somewhat analogous. 

*Genres analysis*

For gross revenue prediction.

```{r, echo = FALSE, fig.width = 10, fig.align = "center"}
genres_model_gross <- lm(gross ~ genre, data = movies_and_genres)
summary(genres_model_gross)
intercept1 <- lm(movies_and_genres$gross ~ genres_model_gross$fitted)$coefficients[[1]]

movies_and_genres_full <- data.frame(movies_and_genres[,c("gross","score","genre")], predicted_gross = genres_model_gross$fitted)
avg_gross <- movies_and_genres_full[, 3:4]
avg_gross <- avg_gross[!duplicated(avg_gross$genre), ]
avg_gross <- avg_gross[order(avg_gross$predicted_gross), ]
rownames(avg_gross) <- 1:dim(avg_gross)[1]

ggplot() + 
    geom_point(aes(x = movies_and_genres_full$predicted_gross, y = movies_and_genres_full$gross, colour = movies_and_genres_full$genre), alpha = 0.1) + 
    geom_abline(intercept = intercept1) + 
    geom_point(aes(x = avg_gross$predicted_gross, y = avg_gross$predicted_gross, colour = avg_gross$genre), 
               size = 2, shape = 21, stroke = 2) + 
    geom_text(aes(x = avg_gross[seq(1, dim(avg_gross)[1], 2), ]$predicted_gross, 
                   y = avg_gross[seq(1, dim(avg_gross)[1], 2), ]$predicted_gross, 
                   label = avg_gross[seq(1, dim(avg_gross)[1], 2), ]$genre), 
               check_overlap = F, nudge_y = -0.2, nudge_x = 0, size = 3, angle = 45, fontface = "bold") + 
    geom_text(aes(x = avg_gross[seq(2, dim(avg_gross)[1], 2), ]$predicted_gross, 
                   y = avg_gross[seq(2, dim(avg_gross)[1], 2), ]$predicted_gross, 
                   label = avg_gross[seq(2, dim(avg_gross)[1], 2), ]$genre), 
               check_overlap = F, nudge_y = 0.2, nudge_x = 0, size = 3, angle = 45, fontface = "bold") + 
    scale_y_log10(breaks = c(1e+02, 1e+04, 1e+06, 1e+08, 1e+10), 
                labels = c("100", "10,000", "1 million", "100 millions", "1 billion")) +
    scale_x_log10(breaks = c(0.15e+08, 0.5e+08, 1e+08), 
                labels = c("15 millions", "50 millions", "100 millions")) +
    labs(title = "Gross Revenue for different genres", x = "Predicted Gross Revenue", y = "Observed Gross Revenue") +
    theme_few() + 
    theme(legend.position = "None")
```

For IMDB score prediction.

```{r, echo = FALSE, fig.width = 10, fig.align = "center"}
genres_model_score <- lm(score ~ genre, data = movies_and_genres)
summary(genres_model_score)
intercept2 <- lm(movies_and_genres$score ~ genres_model_score$fitted)$coefficients[[1]]

movies_and_genres_full <- data.frame(movies_and_genres[,c("gross","score","genre")], predicted_score = genres_model_score$fitted)
avg_score <- movies_and_genres_full[, 3:4]
avg_score <- avg_score[!duplicated(avg_score$genre), ]
avg_score <- avg_score[order(avg_score$predicted_score), ]
rownames(avg_score) <- 1:dim(avg_score)[1]

ggplot() + 
    geom_jitter(aes(x = movies_and_genres_full$predicted_score, y = movies_and_genres_full$score, colour = movies_and_genres_full$genre), alpha = 0.1) + 
    geom_abline(intercept = intercept2) + 
    geom_point(aes(x = avg_score$predicted_score, y = avg_score$predicted_score, colour = avg_score$genre), 
               size = 2, shape = 21, stroke = 2) + 
    geom_text(aes(x = avg_score[seq(1, dim(avg_score)[1], 2), ]$predicted_score, 
                   y = avg_score[seq(1, dim(avg_score)[1], 2), ]$predicted_score, 
                   label = avg_score[seq(1, dim(avg_score)[1], 2), ]$genre), 
               check_overlap = F, nudge_y = -0.2, nudge_x = 0, size = 3, angle = 45, fontface = "bold") + 
    geom_text(aes(x = avg_score[seq(2, dim(avg_score)[1], 2), ]$predicted_score, 
                   y = avg_score[seq(2, dim(avg_score)[1], 2), ]$predicted_score, 
                   label = avg_score[seq(2, dim(avg_score)[1], 2), ]$genre), 
               check_overlap = F, nudge_y = 0.2, nudge_x = 0, size = 3, angle = 45, fontface = "bold") + 
    scale_y_continuous(breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9)) +
    scale_x_continuous(breaks = c(6, 6.5, 7)) +
    labs(title = "IMDB Score for different genres", x = "Predicted IMDB Score", y = "Observed IMDB Score") +
    theme_few() + 
    theme(legend.position = "None")
```

*Keywords analysis*

For gross revenue prediction.

```{r, echo = FALSE, fig.width = 10, fig.align = "center"}
keywords_model_gross <- lm(gross ~ keywords, data = movies_and_keywords)
summary(keywords_model_gross)
intercept3 <- lm(movies_and_keywords$gross ~ keywords_model_gross$fitted)$coefficients[[1]]

movies_and_keywords_full <- data.frame(movies_and_keywords, predicted_gross = keywords_model_gross$fitted)
avg_gross <- movies_and_keywords_full[, 3:4]
avg_gross <- avg_gross[!duplicated(avg_gross$keywords), ]
avg_gross <- avg_gross[order(avg_gross$predicted_gross), ]
rownames(avg_gross) <- 1:dim(avg_gross)[1]

ggplot() + 
    geom_point(aes(x = movies_and_keywords_full$predicted_gross, y = movies_and_keywords_full$gross, 
                   colour = movies_and_keywords_full$keywords), alpha = 0.1) + 
    geom_abline(intercept = intercept3) + 
    geom_point(aes(x = avg_gross$predicted_gross, y = avg_gross$predicted_gross, colour = avg_gross$keywords), 
               size = 2, shape = 21, stroke = 2) + 
    geom_text(aes(x = avg_gross[seq(1, dim(avg_gross)[1], 2), ]$predicted_gross, 
                   y = avg_gross[seq(1, dim(avg_gross)[1], 2), ]$predicted_gross, 
                   label = avg_gross[seq(1, dim(avg_gross)[1], 2), ]$keywords), 
               check_overlap = F, nudge_y = -0.2, nudge_x = 0, size = 3, angle = 45, fontface = "bold") + 
    geom_text(aes(x = avg_gross[seq(2, dim(avg_gross)[1], 2), ]$predicted_gross, 
                   y = avg_gross[seq(2, dim(avg_gross)[1], 2), ]$predicted_gross, 
                   label = avg_gross[seq(2, dim(avg_gross)[1], 2), ]$keywords), 
               check_overlap = F, nudge_y = 0.2, nudge_x = 0, size = 3, angle = 45, fontface = "bold") + 
    scale_y_log10(breaks = c(1e+02, 1e+04, 1e+06, 1e+08, 1e+10), 
                labels = c("100", "10,000", "1 million", "100 millions", "1 billion")) +
    scale_x_log10(breaks = c(0.3e+08, 0.5e+08, 0.7e+08), 
                labels = c("30 millions", "50 millions", "70 millions")) +
    labs(title = "Gross Revenue for different keywords", x = "Predicted Gross Revenue", y = "Observed Gross Revenue") +
    theme_few() + 
    theme(legend.position = "None")
```

For IMDB score prediction.

```{r, echo = FALSE, fig.width = 10, fig.align = "center"}
keywords_model_score <- lm(score ~ keywords, data = movies_and_keywords)
summary(keywords_model_score)
intercept4 <- lm(movies_and_keywords$score ~ keywords_model_score$fitted)$coefficients[[1]]

movies_and_keywords_full <- data.frame(movies_and_keywords, predicted_score = keywords_model_score$fitted)
avg_score <- movies_and_keywords_full[, 3:4]
avg_score <- avg_score[!duplicated(avg_score$keywords), ]
avg_score <- avg_score[order(avg_score$predicted_score), ]
rownames(avg_score) <- 1:dim(avg_score)[1]

ggplot() + 
    geom_jitter(aes(x = movies_and_keywords_full$predicted_score, y = movies_and_keywords_full$score, 
                    colour = movies_and_keywords_full$keywords), alpha = 0.1) + 
    geom_abline(intercept = intercept4) + 
    geom_point(aes(x = avg_score$predicted_score, y = avg_score$predicted_score, colour = avg_score$keywords), 
               size = 2, shape = 21, stroke = 2) + 
    geom_text(aes(x = avg_score[seq(1, dim(avg_score)[1], 2), ]$predicted_score, 
                   y = avg_score[seq(1, dim(avg_score)[1], 2), ]$predicted_score, 
                   label = avg_score[seq(1, dim(avg_score)[1], 2), ]$keywords), 
               check_overlap = F, nudge_y = -0.2, nudge_x = 0, size = 3, angle = 45, fontface = "bold") + 
    geom_text(aes(x = avg_score[seq(2, dim(avg_score)[1], 2), ]$predicted_score, 
                   y = avg_score[seq(2, dim(avg_score)[1], 2), ]$predicted_score, 
                   label = avg_score[seq(2, dim(avg_score)[1], 2), ]$keywords), 
               check_overlap = F, nudge_y = 0.2, nudge_x = 0, size = 3, angle = 45, fontface = "bold") + 
    scale_y_continuous(breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9)) +
    scale_x_continuous(breaks = c(6.1, 6.3, 6.5, 6.7)) +
    labs(title = "IMDB Score for different keywords", x = "Predicted IMDB Score", y = "Observed IMDB Score") +
    theme_few() + 
    theme(legend.position = "None")
```

When we actually make predictions based on a linear model for categorical data, the predicted value is equal to the mean of all observations for each categorical value. So, for each genre or keyword, the predicted value of the gross revenue is equal to the mean value of gross revenues of all the movies of that genre or of that keyword, e.g. the predicted gross revenue for a "Drama" movie is equal to the mean of gross revenues of all the observed "Drama" movies.

### Steven

Test whether, on average, European movies get higher IMDB scores than North American ones.
H0 -> Europe and North America get equal scores


```{r, echo = FALSE}
# make dataframes for North America and Europe
North_America <- movies[movies$continent == "North America",]
Europe <- movies[movies$continent == "Europe",]

# separate IMDB scores 
North_America <- North_America[, c("imdb_score", "continent")]
Europe <- Europe[, c("imdb_score", "continent")]

t.test(Europe$imdb_score, North_America$imdb_score)

# combine two data frames
comb <- rbind(Europe, North_America)

# plot densities
ggplot(comb, aes(x = comb$imdb_score)) +
  geom_density() +
  geom_density(aes(x = comb$imdb_score, fill = continent, alpha = 0.3)) +
  xlab("IMDB score")
```

### Louise

*Would potentially like to do some inference regarding directors*

```{r echo=FALSE, message=FALSE}
##plot for imdb rating vs score
## to do - sort out the axes
ggplot(movieswithdirectordata, aes(x = dir_number_of_movies, y = imdb_score)) + 
  geom_jitter(alpha = 0.2, width = 0.05) + geom_smooth() +
  labs(x = "Number of movies in sample", y = "IMDB Score")
```

```{r echo=FALSE}
##cor test for imdb rating vs # of movies
cor.test(movieswithdirectordata$imdb_score,movieswithdirectordata$dir_number_of_movies)
##does seem like very loosely positively correlated and is probably because of the correlation with budget- more analysis to come.
##cor test for gross score vs # of movies
cor.test(movieswithdirectordata$gross,movieswithdirectordata$dir_number_of_movies)
##does seem like somewhat positively correlated - although we can see from the graph that this doesn't seem linear.
```

These correlation tests do infer that there is a slight positive correlation between the two outcome variables (gross and imdb score) and the # of movies the director has in the sample. However, the impact on gross revenue does not look to be linear, and neither of the correlations seem to be particularly strong. Whether or not a director is prolific does not seem to have a strong impact on the quality (as proxied by imdb score) or popularity (as proxied by gross revenue) of a movie.

```{r echo=FALSE} 
options(scipen=1000000000)

movieswithdirectordata$more_than_one_movie <- as.factor(movieswithdirectordata$more_than_one_movie)
ggplot(movieswithdirectordata, aes(x=movieswithdirectordata$more_than_one_movie, y=gross)) + geom_boxplot() 

t.test(movieswithdirectordata$gross[movieswithdirectordata$more_than_one_movie==0], movieswithdirectordata$gross[movieswithdirectordata$more_than_one_movie==1])
```

```{r}
ggplot(movieswithdirectordata, aes(x = gross, fill = more_than_one_movie)) + geom_density(alpha = 0.5) + scale_y_continuous(label=comma) + scale_x_continuous(label=human_num)
##these look unpleasant, need to make them prettier before uncommenting.
##+ geom_vline(xintercept = mean(movieswithdirectordata$gross[movieswithdirectordata$more_than_one_movie==0])) + ##geom_vline(xintercept = mean(movieswithdirectordata$gross[movieswithdirectordata$more_than_one_movie==1]))
```

# Predictive Data Analysis

###Model Building and Justification
*we will all make two predictive models, one for "gross" and one for "imdb_score", using whatever inputs we can get from our dataset, at a later stage we'll compare them and see whose has the lowest mean squared error (which we can also justify) - and include that into this section*

*We discussed potentially including a new variable into the model, or to build a dual model that has different inputs for movies before 2010, and after 2010, which is the cutover point at which facebook likes for a movie became a meaningful indicator*

```{r echo=FALSE}

sort(names(movies))

model1 <- lm(gross ~ budget, data = movies)
summary(model1)
ggplot(data = movies, aes(x = budget, y = gross)) + geom_point() + geom_smooth(method = "lm") + coord_cartesian(xlim = c(0, 3e8))

model2 <- lm(gross ~ budget + movie_facebook_likes + cast_total_facebook_likes + director_facebook_likes + imdb_score + country, data = movies)
summary(model2)

model3 <- lm(gross ~ budget, data = movies[movies$title_year >= 2010, ])
summary(model3)
ggplot(data = movies[movies$title_year >= 2010, ], aes(x = budget, y = gross)) + geom_point() + geom_smooth(method = "lm") + coord_cartesian(xlim = c(0, 3e8))

model4 <- lm(gross ~ budget + movie_facebook_likes + cast_total_facebook_likes + director_facebook_likes + imdb_score + country, data = movies[movies$title_year >= 2010, ])
summary(model4)

```


###Model Performance
*we will then test this model using the test dataset, make a plot of the predictions against the actual values, and calculate the MSE/other success statistics*

#Conclusion
*to be completed after our analysis*

#To be removed- Notes and comments:

At the end of the assignment we should go back to:

* Check coding standards are consistent (and align with his recommendation - http://adv-r.had.co.nz/Style.html)
* Check language is consistent (tense / case)
* Convert ggplots into the same theme - colour scheme, fonts, etc.
* All assumptions have been noted in the appropriate sections
* We think we're roughly aiming for 20ish pages - tbd at a later stage
* Make sure we don't use language that implies causation when we can only infer correlation
* Double check each others' analyses for Simpson's paradox.
* Maybe put all libraries at the top?
